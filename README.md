# RAG Chat Storage Microservice

## Overview

This is a production-ready backend microservice responsible for persisting and managing chat conversations generated by a RAG (Retrieval-Augmented Generation) based chatbot system.

In a RAG architecture, an AI assistant answers user questions by retrieving relevant context from a knowledge base (e.g. a vector store) before generating a response. This microservice acts as the **storage layer** — it sits between your RAG application backend and the database, providing a clean API to save and retrieve the full conversation history including the retrieved context alongside each message.

### What it provides

- **Session management** — create, rename, favorite, and delete chat sessions per user
- **Message storage** — store both user and assistant messages with optional RAG context
- **Message history** — retrieve paginated message history for any session
- **API key authentication** — all endpoints are secured with a configurable API key
- **Rate limiting** — protects the API from abuse with per-client request limits
- **CORS support** — configurable allowed origins for frontend integration
- **Swagger UI** — interactive API documentation out of the box
- **Health check** — endpoint for monitoring and container orchestration
- **Centralized logging** — structured logs written to console and rolling log files
- **Dockerized** — fully containerized with Docker Compose for easy local setup

---

## Tech Stack

- **Java 21** + **Spring Boot 4**
- **PostgreSQL 15** — persistent storage
- **Spring Security** — API key authentication
- **Bucket4j** — rate limiting
- **Log4j2** — centralized logging
- **SpringDoc OpenAPI** — Swagger UI
- **Docker + Docker Compose** — containerized setup
- **MapStruct + Lombok** — mapping and boilerplate reduction

---

## Prerequisites

- [Docker](https://www.docker.com/) and Docker Compose
- Java 21 (only if running locally without Docker)
- Maven (only if running locally without Docker)

---

## Environment Variables

Copy `.env.example` to `.env` and fill in the values:

```bash
cp .env.example .env
```

| Variable | Description | Default |
|---|---|---|
| `API_KEY` | Secret key required for all API requests | — |
| `DB_URL` | PostgreSQL JDBC URL | `jdbc:postgresql://localhost:5432/chatdb` |
| `DB_USERNAME` | PostgreSQL username | `chatuser` |
| `DB_PASSWORD` | PostgreSQL password | `chatpass` |
| `ALLOWED_ORIGINS` | Comma-separated list of allowed CORS origins | `http://localhost:3000` |
| `RATE_LIMIT_CAPACITY` | Max burst requests per client | `60` |
| `RATE_LIMIT_REFILL_TOKENS` | Tokens refilled per period | `60` |
| `RATE_LIMIT_REFILL_MINUTES` | Refill period in minutes | `1` |

---

## Running with Docker (Recommended)

1. Clone the repository:
```bash
git clone <repository-url>
cd rag-chat
```

2. Set up environment variables:
```bash
cp .env.example .env
# Edit .env and set your API_KEY and any other values
```

3. Build and start all services:
```bash
docker-compose up --build
```

This builds the Spring Boot app image and starts three containers:

| Service | URL | Description |
|---|---|---|
| **Spring Boot App** | `http://localhost:8080` | The microservice |
| **pgAdmin** | `http://localhost:5050` | Database management UI |
| **PostgreSQL** | `localhost:5432` | Database |

pgAdmin credentials: `admin@example.com` / `admin`

> **Note:** Inside Docker, the app connects to PostgreSQL using the service name `postgres` — this is handled automatically by docker-compose. The `DB_URL` in your `.env` file (`localhost:5432`) is only used when running locally.

To stop:
```bash
docker-compose down
```

To stop and remove all data:
```bash
docker-compose down -v
```

---

## Running Locally

1. Clone the repository:
```bash
git clone <repository-url>
cd rag-chat
```

2. Set up environment variables:
```bash
cp .env.example .env
# Edit .env and set your API_KEY and database credentials
```

3. Start PostgreSQL and pgAdmin via Docker:
```bash
docker-compose up postgres pgadmin -d
```

4. Build the project:
```bash
./mvnw clean package -DskipTests
```

5. Run the application:
```bash
./mvnw spring-boot:run
```

The app will be available at `http://localhost:8080`.

---

## Authentication

All `/api/**` endpoints require an API key passed as a request header:

```
X-API-Key: your-api-key-here
```

Requests without a valid API key will receive `401 Unauthorized`.

---

## Rate Limiting

Each client is limited to **60 requests per minute** (configurable via env vars). Exceeding the limit returns `429 Too Many Requests`.

---

## API Reference

All endpoints also require the user identifier header:

```
X-User-Id: your-user-id
```

---

### Sessions

#### Create a session
```
POST /api/sessions
```
**Request body:**
```json
{
  "title": "My Chat Session"
}
```
**Response:** `201 Created`
```json
{
  "id": "uuid",
  "userId": "user-123",
  "title": "My Chat Session",
  "isFavorite": false,
  "createdAt": "2026-02-19T10:00:00",
  "updatedAt": "2026-02-19T10:00:00"
}
```

---

#### Get all sessions
```
GET /api/sessions
```
**Response:** `200 OK` — list of sessions ordered by most recently updated.

---

#### Get favorite sessions
```
GET /api/sessions/favorites
```
**Response:** `200 OK` — list of favorited sessions.

---

#### Get a session by ID
```
GET /api/sessions/{sessionId}
```
**Response:** `200 OK` — session object, or `404` if not found.

---

#### Rename a session
```
PATCH /api/sessions/{sessionId}/rename
```
**Request body:**
```json
{
  "title": "New Title"
}
```
**Response:** `200 OK` — updated session.

---

#### Toggle favorite
```
PATCH /api/sessions/{sessionId}/favorite
```
**Response:** `200 OK` — session with flipped `isFavorite` flag.

---

#### Delete a session
```
DELETE /api/sessions/{sessionId}
```
**Response:** `204 No Content`. Also deletes all messages in the session.

---

### Messages

#### Add a message
```
POST /api/sessions/{sessionId}/messages
```
**Request body:**
```json
{
  "sender": "USER",
  "content": "What is RAG?",
  "context": "optional retrieved context from vector store"
}
```
`sender` must be `USER` or `ASSISTANT`.

**Response:** `201 Created`
```json
{
  "id": "uuid",
  "sender": "USER",
  "content": "What is RAG?",
  "context": "optional retrieved context from vector store",
  "createdAt": "2026-02-19T10:00:00"
}
```

---

#### Get messages (paginated)
```
GET /api/sessions/{sessionId}/messages?page=0&size=20
```

| Query param | Default | Description |
|---|---|---|
| `page` | `0` | Page number (zero-based) |
| `size` | `20` | Number of messages per page |

**Response:** `200 OK`
```json
{
  "content": [ ... ],
  "page": 0,
  "size": 20,
  "totalElements": 45,
  "totalPages": 3,
  "last": false
}
```

---

## Error Responses

All errors return a consistent shape:

```json
{
  "status": 404,
  "error": "Not Found",
  "message": "Session not found with id: ...",
  "timestamp": "2026-02-19T10:00:00",
  "path": "/api/sessions/..."
}
```

Validation errors additionally include a field-level `errors` map:

```json
{
  "status": 400,
  "error": "Bad Request",
  "message": "Validation failed",
  "timestamp": "2026-02-19T10:00:00",
  "path": "/api/sessions",
  "errors": {
    "title": "must not be blank"
  }
}
```

---

## API Documentation (Swagger)

Interactive API docs are available at:

```
http://localhost:8080/swagger-ui.html
```

OpenAPI JSON spec:
```
http://localhost:8080/v3/api-docs
```

To authorize in Swagger UI, click **Authorize** and enter your API key.

---

## Health Check

```
GET http://localhost:8080/actuator/health
```

Returns `200 OK` with application and database status. No authentication required.

```json
{
  "status": "UP",
  "components": {
    "db": { "status": "UP" },
    "diskSpace": { "status": "UP" }
  }
}
```

---

## Running Tests

```bash
./mvnw test
```

---

## Logs

Application logs are written to both the console and `logs/rag-chat.log`. Log files roll daily and are retained for 30 days.
